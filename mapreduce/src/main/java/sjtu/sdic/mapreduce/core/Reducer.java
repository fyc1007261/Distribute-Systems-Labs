package sjtu.sdic.mapreduce.core;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import sjtu.sdic.mapreduce.common.KeyValue;
import sjtu.sdic.mapreduce.common.Utils;

import java.io.*;
import java.lang.reflect.Array;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.Key;
import java.util.*;

/**
 * Created by Cachhe on 2019/4/19.
 */
public class Reducer {

    /**
     * 
     * 	doReduce manages one reduce task: it should read the intermediate
     * 	files for the task, sort the intermediate key/value pairs by key,
     * 	call the user-defined reduce function {@code reduceFunc} for each key,
     * 	and write reduceFunc's output to disk.
     * 	
     * 	You'll need to read one intermediate file from each map task;
     * 	{@code reduceName(jobName, m, reduceTask)} yields the file
     * 	name from map task m.
     *
     * 	Your {@code doMap()} encoded the key/value pairs in the intermediate
     * 	files, so you will need to decode them. If you used JSON, you can refer
     * 	to related docs to know how to decode.
     * 	
     *  In the original paper, sorting is optional but helpful. Here you are
     *  also required to do sorting. Lib is allowed.
     * 	
     * 	{@code reduceFunc()} is the application's reduce function. You should
     * 	call it once per distinct key, with a slice of all the values
     * 	for that key. {@code reduceFunc()} returns the reduced value for that
     * 	key.
     * 	
     * 	You should write the reduce output as JSON encoded KeyValue
     * 	objects to the file named outFile. We require you to use JSON
     * 	because that is what the merger than combines the output
     * 	from all the reduce tasks expects. There is nothing special about
     * 	JSON -- it is just the marshalling format we chose to use.
     * 	
     * 	Your code here (Part I).
     * 	
     * 	
     * @param jobName the name of the whole MapReduce job
     * @param reduceTask which reduce task this is
     * @param outFile write the output here
     * @param nMap the number of map tasks that were run ("M" in the paper)
     * @param reduceFunc user-defined reduce function
     */
    public static void doReduce(String jobName, int reduceTask, String outFile, int nMap, ReduceFunc reduceFunc) {
        // read each file generated by the doMap().
//        System.out.println("Entering doReduce.");
        List<KeyValue> keyValueList = new ArrayList<>();
        for (int i = 0; i < nMap; i++){
            String inFile = Utils.reduceName(jobName, i, reduceTask);
            String contents = "";
            try{
                contents = new String(Files.readAllBytes(new File(inFile).toPath()));
            }
            catch (IOException e){
                e.printStackTrace();
            }
            List<KeyValue> subKeyValueList = JSONArray.parseArray(contents.toString(), KeyValue.class);
            keyValueList.addAll(subKeyValueList);
        }

        // sort the List by key.
        Collections.sort(keyValueList, new Comparator<KeyValue>() {
            @Override
            public int compare(KeyValue o1, KeyValue o2) {
                return o1.key.compareTo(o2.key);
            }
        });
        // for each key, generate a List of values and feed it into the reduceTask.
        List<String> temp = new ArrayList<>();
        JSONObject jsonObject = new JSONObject();

        for (int i = 0; i < keyValueList.size(); i++){
            if (i == 0 || !keyValueList.get(i).key.equals(keyValueList.get(i-1).key)){
                // a new key
                if (i != 0){
                    // store the old temp.
                    String result = reduceFunc.reduce(keyValueList.get(i-1).key,
                            temp.toArray(new String[temp.size()]));
                    jsonObject.put(keyValueList.get(i-1).key, result);
                    temp.clear();
                }
                temp.add(keyValueList.get(i).value);
            }
        }
        String last = reduceFunc.reduce(keyValueList.get(keyValueList.size()-1).key,
                temp.toArray(new String[temp.size()]));
        jsonObject.put(keyValueList.get(keyValueList.size()-1).key, last);
        // Output the result.
//        String toWrite = JSONArray.toJSONString(ReducedKeyValues);
        String toWrite = jsonObject.toJSONString();
        File out = new File(outFile);
        OutputStream outputStream;
        try{
            outputStream = new FileOutputStream(out);
            outputStream.write(toWrite.getBytes());
            outputStream.close();
        }
        catch (IOException e){
            e.printStackTrace();
        }
//        System.out.println("Exiting doReduce.");
    }

}
